# Release

A major difference between open source projects and proprietary ones is the lack of centralized control over the development team. When a new release is being prepared, this difference is especially stark: ifa single corporation manages the entire development team, it can ask them to focus on an upcoming re- lease, putting aside new feature development and non-critical bug fixing until the release is done. But open source developer communities are are not so monolithic. People work on the project for all sortsof reasons, and those not interested in helping with a given release still want to continue regular de- velopment work while the release is going on. Because development doesn't stop, open source release processes tend to take longer, but be less disruptive, than commercial release processes. It's a bit like highway repair. There are two ways to fix a road: you can shut it down completely, so that a repair crew can swarm all over it at full capacity until the problem is solved, or you can work on a couple of lanes at a time, while leaving the others open to traffic. The first way is very efficient for the repair crew, but not for anyone else — the road is entirely shut down until the job is done. The second way involves much more time and trouble for the repair crew \(now they have to work with fewer people and less equipment, in cramped conditions, with flaggers to slow and direct traffic, etc.\), but at least the road remains use- able, albeit not at full capacity.Open source projects tend to work the second way. In fact, for a mature piece of software with several different release lines being maintained simultaneously, the project is sort of in a permanent state of mi- nor road repair. There are always a couple of lanes closed; a consistent but low level of background in- convenience is always being tolerated by the development group as a whole, so that releases get made on a regular schedule.The model that makes this possible generalizes to more than just releases. It's the principle of paralleliz- ing tasks that are not mutually interdependent — a principle that is by no means unique to open source development, of course, but one which open source projects implement in their own particular way. They cannot afford to annoy either the roadwork crew or the regular traffic too much, but they also can- not afford to have people dedicated to standing by the orange cones and flagging traffic along. Thus they gravitate toward processes that have flat, constant levels of administrative overhead, rather than peaks and valleys. Developers are generally willing to work with small but consistent amounts of inconve- nience; the predictability allows them to come and go without worrying about whether their schedule will clash with what's happening in the project. But if the project were subject to a master schedule in which some activities excluded other activities, the result would be a lot of developers sitting idle a lot of the time — which would be not only inefficient but boring, and therefore dangerous, in that a bored developer is likely to soon be an ex-developer.Release work is usually the most noticeable non-development task that happens in parallel with devel- opment, so the methods described in the following sections are geared mostly toward enabling releases. However, note that they also apply to other parallelizable tasks, such as translations and internationaliza- tion, broad API changes made gradually across the entire codebase, etc.

