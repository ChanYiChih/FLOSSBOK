# Maintaining Multiple Release Lines

Most mature projects have multiple release lines in parallel. This means that they can have release 1.0.0, 1.0.1 and 1.0.2 while they also have the release 1.1.0. They will maintain both lines simultaneously. This is good because users are very careful about upgrade. So most of them will keep using the current old version until the new version has a stable release, then they will try to upgrade. But there are also adventurers who like to try the new features in the new version first. So it can satisfy both users by having multiple release lines in parallel.

After the 1.1.x line is more stable, the 1.0.x line can be cut. This can be announced in 1.1.x release announcement, or in a separate announcement. But no matter way you use, you need to let users know so that they can make upgrade decisions accordingly.

Some projects still have a time window in which they previous release lines are still maintained, which means that they still accept bug reports and making maintenance releases when significant bugs are found. Other projects don't give this kind support for previous lines anymore, but they watch incoming bug reports to calculate how many people are still using the older line. When the percentage drops below a certain point, they will cut that line.

## Security Releases

A security release is a release made solely to close a security vulnerability. The code that fixes the bug cannot be made public until the release is available, which means not only that the fixes cannot be com- mitted to the repository until the day of the release, but also that the release cannot be publicly tested be- fore it goes out the door. Obviously, the developers can examine the fix among themselves, and test the release privately, but widespread real-world testing is not possible.

Because of this lack of testing, a security release should always consist of some existing release plus the fixes for the security bug, with no other changes. This is because the more changes you ship without testing, the more likely that one of them will cause a new bug, perhaps even a new security bug! This conservatism is also friendly to administrators who may need to deploy the security fix, but whose up- grade policy stipulates that they not deploy any other changes at the same time.

Making a security release sometimes involves some minor deception. For example, the project may have been working on a 1.1.3 release, with certain bug fixes to 1.1.2 already publicly declared, when a securi-ty report comes in. Naturally, the developers cannot talk about the security problem until they make the fix available; until then, they must continue to talk publicly as though 1.1.3 will be what it's always been planned to be. But when 1.1.3 actually comes out, it will differ from 1.1.2 only in the security fixes, and all those other fixes will have been deferred to 1.1.4 \(which, of course, will now also contain the securi- ty fix, as will all other future releases\).

You could add an extra component to an existing release to indicate that it contains security changes only. For example, people would be able to tell just from the numbers that 1.1.2.1 is a security release against 1.1.2, and they would know that any release "higher" than that \(e.g., 1.1.3, 1.2.0, etc.\) contains the same security fixes. For those in the know, this system conveys a lot of information. On the other hand, for those not following the project closely, it can be a bit confusing to see a three-component re- lease number most of the time with an occasional four-component one thrown in seemingly at random. Most projects I've looked at choose consistency and simply use the next regularly scheduled number for security releases, even when it means shifting other planned releases by one number.

